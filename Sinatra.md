
Разработка состоит из двух этапов: сбор данных (словаря) и собственно Quiz.

## Сбор данных

У меня не было офлайн-словаря с определениями в удобном виде, который бы понял Ruby, поэтому соберём его
сами на основе имеющегося в Merriam-Webster с помощью [их API](https://dictionaryapi.com).  

Регистрируемся и получаем ключ, тут сложностей нет. Бесплатная версия даёт два ключа на два словаря (основной и тезаурус) и ограничивает использования 1000 запросами в день.  

Можно было конечно и не собирать данные, а просто обращаться к Merriam-Webster по API при каждом тесте, это даже было бы намного проще реализовать.
Но я увидел два минуса: 
1. Зависимость. От сети и от внешнего источника. Когда данные будут локально, за ними не придётся каждый раз ходить по сети. Плюс их можно будет спокойно менять, подтюнить, проводить любые манипуляции. Что даёт больше свободы, чем получать всегда стандартизированный ответ.
2. Эта причина вряд ли когда-то возникнет, но если делать приложение общедоступным, то встанет вопрос о лицензии и лимитах. Когда данные локальны, этого нет.

### Merriam-Webster API
Документация по API в Merriam-Webster довольно формальная, но подробная.

Запрос будет выглядеть примерно так:
```
url = URI('https://www.dictionaryapi.com/api/v3/references/collegiate/json/' + word + '?key=' + key)
```
где `word` будет слово из словаря Oxford 3000.

Затем получаем ответ и преобразуем полученный JSON. В ответе всегда массив, поэтому берём первый же его элемент:
```  
  response = http.request(request)
  parsed_json =  JSON.parse(response.body)
  response_hash = parsed_json[0]
```

Не совсем понятно, почему массив, может так принято, но я бы подразумевал, что это даёт возможность запросить более одного слова в рамках запроса, но, судя по всему, нет.

Ответ имеет довольно сложную струтуру, в нём куча всяких элементов типа `def` или `sseq`.
Они конечно расписаны в документации, но нам из всего этого пока нужно только определение.

### Определения
Определение обычно содержит кучу всякого инлайн-форматирования:
```
"{bc}having or marked by great {a_link|volume} or bulk {bc}{sx|large||} "
```

И это первая засада. Возможно получать определение без этого форматирования в документации я не нашёл, возможно плохо искал.
Варианта два:
+ Использовать регулярные выражения и вычистить все эти `{bc}`, но их там куча разных видо и иногда внутри фигурных скобок идёт часть самого определения.
+ Использовать другой "продукт" Merriam-Webster: не словарь, а тезаурус. Определения в нём немного другие, здесь далеко не всегда даётся первое значение.

Пока остановился на первом. Но второй вариант подсказал идею использовать тезаурус в приложении тоже.

### Вложенность

Следующая засада — вложенность. Ответ — это массив, внутри которого хэш (Hash), внутри которого массив и так далее…

Её конечно тоже можно разобрать, чтобы получилось что-то вроде `['def'][0]['sseq'][0][1]`.
И это сработало на большинстве определений. Но когда один из элементов нет или он вложен по-другому, то считается пустым (`nil`), и какие-то действия (например, обращение к вложенному элементу) с ним производить уже нельзя — это вызовет ошибку.

На помощь приходит метод `dig`, появившийся в Ruby 2.3.0. Если вложенность отличается, он не будет возвращать ошибку, а выдаст `nil` только в самом конце операции.
```ruby
  sseq = response_hash['def'][0]['sseq']
  definition = sseq.dig(0, 0, 1, 'dt', 0, 1)
  if definition.nil?
    definition = sseq.dig(0, 0, 1, 'sense', 'dt', 0, 1)
  end
```    
Правда и он помогал не всегда, иногда определения оставались `nil`.
Такие слова будем складывать в отдельный массив, чтобы обработать позже, возможно вручную:

```ruby
  if definition.nil?
    puts "Definition is nill"
    bad_words << word
  else
    word_array << {'word' => word, 'definition' => definition}
  end
```

### Shortdef или краткое определеине

UPD. Кажется, я нашёл в Merriam-Webster нашлось то, что нужно: краткое описание (поле `shortdef`), которое
помогает решить сразу две задачи:
+ Структура. `shortdef` лежит в корне JSON, возвращаемого в HTTP-ответе. Не надо 
капаться внутри массивов и хешей.
+ Форматирование. Насколько я пока могу видеть, в кратком описании не применяются все эти `{bc}` и прочие теги, ссылки, примеры. Определения по сути являются обычным текстом, не нужно чистить их с помощью регулярных выражений.

Попробовал на примерно 200 словах, вроде бы пока оба пункта подтверждаются.

Единственный вопрос было в том, а чем же эти краткие описание отличаются от полных. Вдруг они слишком узкие и непонятные.
Документация Merriam-Webster даёт такое определение:

> A short definition provides a highly abridged version of the main definition section, consisting of just the definition text for the first three senses. It is not meant to be displayed along with the full entry, but instead as an alternative, shortened preview of the entry content.

Вручную сравнивать все 200 примеров я конечно не стал, но на паре слов показалось, что краткое определение вполне понятное. Можно использовать.

### Заполнение массива полученными данными

Итак, у нас есть слово и его определение. Добавляем эту пару в виде хэша в массив:
```ruby
word_array = []
word_array << {'word' => word, 'definition' => definition}
```
Теперь всё вышеперечисленное (кроме объявления `word_array`) складывам в Proc:
```ruby
   search_definitions = Proc.new { |word|
   url =...
   }
```

  И вызываем этот Proc в отношении нашего списка Oxford 3000 некоторое количество раз (20 для примера):
```ruby
for i in $oxford.first(20) do
  search_definitions.call(i)
end
```
                     
Результатом будет массив из 20 элементов, каждый из которых является хэшом-парой слово-определение:
```ruby
print word_array
$definitions = [{"word"=>"a", "definition"=>"the 1st letter of the English alphabet"}, {"word"=>"abandon", "definition"=>"to give up to the control or influence of another person or agent"}, {"word"=>"ability", "definition"=>"the quality or state of being able "}, ...]
```

## Quiz

Тест на знание слов из Oxford 3000 выполнен в виде веб-приложения на базе микрофреймворка Sinatra.

### Prerequisites

Сначала создаём основной файл, например `main.rb`, и прописываем необходимые зависимости:
```ruby
require 'rubygems'
require 'bundler/setup'
require 'sinatra'
require './definitions'
 ```    
Последняя строчка — ссылка на файл `./definitions`, в котором лежит созданный ранее массив.
### Выбор слова и определений

Выбрать слово наугад из списка легко — есть метод `rand`. Сложнее составит массив из четырёх **уникальных** определений.
Делаю примерно так:

```ruby
$arr = []
  def unique_random
    random_number = rand(20)
    until $arr.length == 4
      if $arr.include?(random_number)
        random_number = rand(20)
      else
        $arr << random_number 
      end        
    end
  end
 ```

Теперь нам нужно выбрать слово для теста и пометить одно из четырх определений как верное:

```ruby
  @word = $definitions[$arr[0]]
  $right_definition = $definitions[$arr[0]]['definition']
```

Знак `$` означает в Ruby глобальную переменную.
Такие анализаторы кода как [RuboCop](https://rubocop.org) подсвечивают каждый факт использования глобальной переменной,
так как Ruby Style Guide их не очень поощрает. Но если использовать одну и ту же переменную в разных маршрутах Sinatra, то я пока не вижу другого способа, кроме того, чтобы эта переменная была глобальной.

### Основной шаблон

Все вышеуказанные действия выполнялись в маршруте GET к `/`.
Последней строкой в нём указываем ERB-шаблон, который отвечает за то, как будет выглядеть страница.

```ruby
get '/' do
  erb :index
end
```

Эта строка означает, что в Sinatra должен быть файл `/views/index.erb`.
Расширение `.erb` и путь до файла указывать необязательно, если он лежит в каталоге `views`.

Сначала в этом файле указываем выбранное для тестирования слово:
```html
<p><%= @word['word'] %></p>
```
Затем с помощью заметчального метода `shuffle` перетасовываем весь массив из четырёх определений, чтобы первое определение не всегда было верным:
```ruby
<% $arr.shuffle! %>
```
Каждое из определений будет представлять собой `<input type="radio" ` со следующими параметрами:
+ `id` — пока (кроме как для `label`) не особо используется.
+ `name="definition"` — название параметра, который будет проверяться на правильность.
+ `value='<%= $definitions[$arr[0]]['definition']%>'` — значение этого параметра, то есть проверяемое определение. Здесь для каждого определения будет отличаться только индекс в массиве: `[0]`, `[1]`, `[2]` или `[3]`.
В кавычки пришлось поставить из-за того, что без них `value` принимал значение только до первого пробела, то есть обрезал определения.

Добавляем кнопку, которая будет отправлять данные:
```ruby
<input type="submit" value="Submit">
```

### Обработка ответов

Указанные выше теги заключаются в форму `form` с методом `post`:
```ruby
<form method="post" action="/">
```

Теперь нужно создать маршрут, который будет обрабатывать POST-запросы при нажатии на кноку **Submit**.

```ruby
post '/' do
  if params['reset'] == 'true'
    $abc = 0
    $wrong_answers = 0
    elsif params['definition'] == $right_definition
      $abc = $abc + 1
      else
    $wrong_answers += 1
  end
    
  if $abc + $wrong_answers == 4
    erb :results
  else
    redirect '/'
  end
end
```

Логика такая: если выбранное (отправленное) определение `params['definition']` равно правильному определению `$right_definition`, то увеличиваем число правильных ответов на один (пока что эта переменная названа некрасиво `$abc`).
Если нет, увеличиваем число неправильных ответов (`$wrong_answers += 1`).

Если достигнуто некоторое число ответов (например, 4), то переводим пользователя на страницу с резульатами (`erb :results`).
Если это чисто не достигнуто, считаем, что тест продолжается и вовзаращем на основную страницу (`redirect /`),
что будет выглядеть как следующий вопрос.

### Страница с результатами

Для оформления результатов, создаём в каталоге `views` файл `results.erb` (указание на него уже есть в маршруте, см. выше).

В нём показываем число правильных и неправильных ответов, а также добавляем кнопку для возврата:

```html
<h3>Your results!</h3>
<p>Right answers: <%=$abc %></p>
<p>Wrong answers: <%=$wrong_answers %></p>

<form method="post" action="/">
  <button name='reset' type="submit" value='true'>Get back</button>
</form>
```

В кнопке передаём параметр `reset` со значением `true`.
Это нужно для того, чтобы сбросить счетчик правильных и неправильных ответов.
В маршруте (выше) этот параметр будет обработан так:

```ruby
  if params['reset'] == 'true'
    $abc = 0
    $wrong_answers = 0
```

Этот текст написан в RubyMine 2021.1.2, здесь есть неплохой предпросмотрщик Markdown.      